# 테트로미노 하나를 적절히 놓는다.
# 해당 테트로미노를 마스크로 사용하여 그 마스크값 위에 있는 값만 더하면 됨
# 복잡도 계산
# 모든 모형을 각각 정의했을 때(회전, 대칭) -> 19 가지
# 2차원 리스트 전체 탐색 O(NM) * 19 * 4(모양 클릭)
# O(N^2)

# 1. 모양 정의 (19가지 전부 각각 정의)
# 2. 해당 모양으로 2차원 리스트 브루트포스로 탐색
# 3. max 값 찾으면 됨
import sys
input = sys.stdin.readline

# 모양 정의
blocks = [
    [(0, 0), (0, 1), (0, 2), (0, 3)], # 가로로 긴 막대
    [(0, 0), (1, 0), (2, 0), (3, 0)], # 세로로 긴 막대
    [(0, 0), (1, 0), (0, 1), (1, 1)], # 네모
    [(0, 0), (1, 0), (2, 0), (2, 1)], # ㄴ 4가지 회전
    [(0, 0), (1, 0), (0, 1), (0, 2)],
    [(0, 0), (0, 1), (1, 1), (2, 1)],
    [(1, 0), (1, 1), (1, 2), (0, 2)],
    [(0, 1), (1, 1), (2, 1), (2, 0)], # ㄴ 대칭 후 4가지 회전
    [(0, 0), (1, 0), (1, 1), (1, 2)],
    [(0, 0), (0, 1), (1, 0), (2, 0)],
    [(0, 0), (0, 1), (0, 2), (1, 2)],
    [(0, 0), (1, 0), (1, 1), (2, 1)], # 번개 모양 4가지
    [(1, 0), (1, 1), (0, 1), (0, 2)],
    [(0, 1), (1, 1), (1, 0), (2, 0)],
    [(0, 0), (0, 1), (1, 1), (1, 2)],
    [(0, 0), (0, 1), (1, 1), (0, 2)], # ㅏ 모양 4가지
    [(0, 0), (1, 0), (1, 1), (2, 0)],
    [(1, 0), (1, 1), (0, 1), (1, 2)],
    [(0, 1), (1, 1), (1, 0), (2, 1)]
]

n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]

ans = 0

# 블록 체크
# for block in blocks: # 19개 블록 모양 전부 탐색
#     print(f'========{block}===========')
#     for dx, dy in block: # 블록 모양에 해당하는 숫자 탐색
#         nx = x + dx
#         ny = y + dy
#         if nx >= n or ny >= m:
#             break
#         a[nx][ny] = 1
#     for line in a:
#         print(line)
#     a = [[0] * 4 for _ in range(4)]


# 2차원 리스트 반복 시작
for x in range(n):
    for y in range(m):
        for block in blocks: # 19개 블록 모양 전부 탐색
            temp = 0 # 최대값 탐색을 위한 임시 변수
            for dx, dy in block: # 블록 모양에 해당하는 숫자 탐색
                nx = x + dx
                ny = y + dy
                if nx >= n or ny >= m:
                    break
                temp += a[nx][ny]
            ans = max(ans, temp) # 블록 하나 탐색 후 최대값 지정

print(ans)